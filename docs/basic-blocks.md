Basic Blocks
============
A basic is an abstraction over a maximal sequence of instructions that end in
a control-flow transfer instruction. In Granary, all control-flow transfer
instructions except for `call` terminate basic blocks. See 
[control flow](control-flow.md) for more information about how control-flow
transfers are handled by Granary.

In Granary, a basic block data structure contain three components, and is only
reified /after/ the block has been emitted to the [code cache](code-cache.md).

1.  Block-local storage.
2.  x86 instructions.
3.  Meta information.

1. Block-local Storage
----------------------
Block-local storage is used by Granary clients to store per-basic block
information that can be modified by the instructions within that basic block.
Block-local storage is useful for implementing, among other things, performance
counters.

Block-local storage is defined in `granary/state.h` and extended by client code
in `clients/state.h`. There are two block-local storage data structures: 
`granary::basic_block_state` and `client::basic_block_state`. The former extends
the latter. As a result, changing `client::basic_block_state` implicitly
changes `granary::basic_block_state`. The implication of client extension of
basic block storage is that this form of storage is /only/ available to
translated code: code that is directly generated by Granary for internal uses
(e.g. branch lookup) does not contain block local storage.

Granary ensures that `granary::basic_block_state` is aligned on a 16-byte
boundary and is emitted immediately before any instructions. This placement was
motivated by the ease with which `%rip`-relative addressing emitting code in a
single pass could be performed. That is, when translating a new basic block,
Granary will stage the block in a region of memory that is large enough to
hold the final emitted basic block. As a result, the exact pointer to the basic
block storage can be given to the client for modification and use.

2. x86 Instructions
-------------------
Granary uses DynamoRIO's instruction representation and encoder to translate
and emit instructions into the code cache. Each instruction in a basic block
has one of four states: padding, native, instrumented, and mangled.

A padding instruction is an int3 and should never be executed. A native
instruction should (but this can be subverted) directly map to an instruction
in module/application code. An instrumented instruction is one that client code
has injected and that has no direct correspondence with any native instructions.
Finally, a mangled instruction is one that is internally generated by Granary
for branch lookup, etc.

Granary ensures that there is only one mangled instruction per translated
basic block, i.e. the instruction that terminates the basic block.

3. Meta Information
-------------------
After the instructions, there is a variable-sized data structure representing
meta-information about each basic block. Meta information is aligned on a 16
byte boundary and includes:

1.  Three consecutive int3 instructions, representing a "magic" number.
2.  A one byte tag representing the kind of the basic block. Each kind of basic
    block has different semantics under interrupts.
3.  A "hotness" counter. The hotness counter is intended to be an interrupt
    performance counter.
4.  The number of bytes of instruction code and instruction padding code there
    is. This number of bytes allows us to efficiently calculate the location of
    any block-local storage (if any), as well as the size of the instruction
    byte state set (see below).
5.  The "generating" pc. If this is non-null then this is the native program
    counter that, when translated, generated this basic block.

Immediately following the meta information--although not explicitly represented
in the `basic_block_info` struct--is a bitset representing the state of every
instruction byte in the basic block. The bitset maps each byte of instructions
to two bits of state. The states record the kind of instruction of each byte of
instructions.

This meta information is used when a basic block is [interrupted](interrupts-exceptions.md).